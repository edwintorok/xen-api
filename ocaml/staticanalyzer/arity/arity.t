Test using the examples from the OCaml manual: https://v2.ocaml.org/manual/intfc.html
Type abbreviations are not expanded:

  $ cat >test.ml <<EOF
  > external seek_in : in_channel -> int -> unit = "caml_ml_seek_in"
  > external seek_in_pair: in_channel * int -> unit = "caml_ml_seek_in_pair"
  > type int_endo = int -> int
  > external f : int_endo -> int_endo = "f"
  > external g : (int -> int) -> (int -> int) = "g"
  > EOF
  $ lintcstubs_arity test.ml
  /* AUTOGENERATED FILE, DO NOT EDIT */
  #define CAML_NAME_SPACE
  #define _GNU_SOURCE
  #define _XOPEN_SOURCE 600
  #include <caml/mlvalues.h>
  CAMLprim value caml_ml_seek_in(value, value);
  CAMLprim value caml_ml_seek_in_pair(value);
  CAMLprim value f(value);
  CAMLprim value g(value, value);


Arity <= 5 is implemented directly:
  $ cat >test.ml <<EOF
  > external input : in_channel -> bytes -> int -> int -> int = "input"
  > EOF
  $ lintcstubs_arity test.ml
  /* AUTOGENERATED FILE, DO NOT EDIT */
  #define CAML_NAME_SPACE
  #define _GNU_SOURCE
  #define _XOPEN_SOURCE 600
  #include <caml/mlvalues.h>
  CAMLprim value input(value, value, value, value);

Arity > 5 is implemented differently in bytecode and native code:
  $ cat >test.ml <<EOF
  > external add_nat: nat -> int -> int -> nat -> int -> int -> int -> int
  >                 = "add_nat_bytecode" "add_nat_native"
  > EOF
  $ lintcstubs_arity test.ml
  /* AUTOGENERATED FILE, DO NOT EDIT */
  #define CAML_NAME_SPACE
  #define _GNU_SOURCE
  #define _XOPEN_SOURCE 600
  #include <caml/mlvalues.h>
  CAMLprim value add_nat_bytecode(value *argv, int argn);

Native code can take some arguments unboxed, but that would require a typedtree
to be done correctly (it is possible to redefine 'type int = string'), so just print a warning here.
  $ cat >test.ml <<EOF
  > external foo
  > :  (float [@unboxed])
  > -> (float [@unboxed])
  > -> (float [@unboxed])
  > = "foo_byte" "foo"
  > external foo : float -> float -> float = "foo2_byte" "foo2" [@@unboxed]
  > external f : string -> (int [@untagged]) = "f_byte" "f"
  > EOF
  $ lintcstubs_arity test.ml
  /* AUTOGENERATED FILE, DO NOT EDIT */
  #define CAML_NAME_SPACE
  #define _GNU_SOURCE
  #define _XOPEN_SOURCE 600
  #include <caml/mlvalues.h>
  CAMLprim value foo_byte(value, value);
  CAMLprim value foo2_byte(value, value);
  CAMLprim value f_byte(value);

Noalloc makes it possible to call C code directly, however unboxed is not
supported by this tool for the same reason as above:
  $ cat >test.ml <<EOF
  > external sqrt : float -> float = "caml_sqrt_float" "sqrt"
  > [@@unboxed] [@@noalloc]
  > EOF
  $ lintcstubs_arity test.ml
  /* AUTOGENERATED FILE, DO NOT EDIT */
  #define CAML_NAME_SPACE
  #define _GNU_SOURCE
  #define _XOPEN_SOURCE 600
  #include <caml/mlvalues.h>
  CAMLprim value caml_sqrt_float(value);

Noalloc can also be used without unboxed:
  $ cat >test.ml <<EOF
  > external unsafe_blit: t -> int -> t -> int -> int -> unit =
  >  "caml_floatarray_blit" [@@noalloc]
  > EOF
  $ lintcstubs_arity test.ml
  /* AUTOGENERATED FILE, DO NOT EDIT */
  #define CAML_NAME_SPACE
  #define _GNU_SOURCE
  #define _XOPEN_SOURCE 600
  #include <caml/mlvalues.h>
  CAMLprim value caml_floatarray_blit(value, value, value, value, value);
